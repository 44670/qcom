From d66061439a3a47410cdd39d34cc6a0cecb01c403 Mon Sep 17 00:00:00 2001
From: shaomingliang <shaomingliang@meigsmart.com>
Date: Tue, 08 Nov 2016 17:40:39 +0800
Subject: [PATCH] [BugID]5119 5120 [SLM753_LM15][Description] he070na-lvds-600p-video video mode dsi panel [Solution]he070na-lvds-600p-video video mode dsi panel driver

Change-Id: I8a215ec597445b47fc3df49cb5105b351aa44ebf
---

diff --git a/bootable/bootloader/lk/target/msm8916/rules.mk b/bootable/bootloader/lk/target/msm8916/rules.mk
old mode 100644
new mode 100755
index 6acddef..c7ee1a9
--- a/bootable/bootloader/lk/target/msm8916/rules.mk
+++ b/bootable/bootloader/lk/target/msm8916/rules.mk
@@ -11,7 +11,7 @@
 BASE_ADDR        := 0x80000000
 SCRATCH_ADDR     := 0x90000000
 
-DEFINES += DISPLAY_SPLASH_SCREEN=1
+DEFINES += DISPLAY_SPLASH_SCREEN=0
 DEFINES += DISPLAY_TYPE_MIPI=1
 DEFINES += DISPLAY_TYPE_DSI6G=1
 
diff --git a/device/qcom/slm753/system.prop b/device/qcom/slm753/system.prop
index 95bed20..18cb115 100755
--- a/device/qcom/slm753/system.prop
+++ b/device/qcom/slm753/system.prop
@@ -178,3 +178,6 @@
 
 #Add by ZhangTing 20161022 for bug 4671
 ro.meig.lcd_density=320
+
+# add by eliot shao 20161108 for lianmai 1024x600 lvds lcm
+ro.sf.lcd_density=240
diff --git a/kernel/arch/arm/boot/dts/qcom/dsi-panel-he070na-lvds-600p-video.dtsi b/kernel/arch/arm/boot/dts/qcom/dsi-panel-he070na-lvds-600p-video.dtsi
new file mode 100755
index 0000000..e8e38fb
--- /dev/null
+++ b/kernel/arch/arm/boot/dts/qcom/dsi-panel-he070na-lvds-600p-video.dtsi
@@ -0,0 +1,92 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_he070na_lvds_600p_video: qcom,mdss_dsi_he070na_lvds_600p_video {
+		qcom,mdss-dsi-panel-name = "he070na-lvds-600p-video video mode dsi panel";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <1024>;
+		qcom,mdss-dsi-panel-height = <600>;
+		qcom,mdss-dsi-h-front-porch = <150>;
+		qcom,mdss-dsi-h-back-porch = <150>;
+		qcom,mdss-dsi-h-pulse-width = <20>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <15>;
+		qcom,mdss-dsi-v-front-porch = <15>;
+		qcom,mdss-dsi-v-pulse-width = <5>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = "rgb_swap_rgb";
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		//qcom,mdss-i2c-command;
+		qcom,mdss-icn6202-command;
+		qcom,mdss-i2c-on-command = [  /*i2c reg & command*/
+			20 00
+			21 58
+			22 24
+			23 96
+			24 14
+			25 96
+			26 00
+			27 0F
+			28 05
+			29 0F
+			34 80
+			36 96
+			B5 A0
+			5C FF
+			13 10
+			56 90
+			6B 21
+			69 1C
+			B6 20
+			51 20
+			09 10
+		];
+		qcom,mdss-dsi-pixel-packing = "tight";
+		qcom,mdss-dsi-pixel-alignment = <0>;
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <1>;
+		qcom,mdss-dsi-traffic-mode = "burst_mode";
+		qcom,mdss-dsi-lane-map = "lane_map_0123";
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [65 12 0C 00 34 38 10 16 0F 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x05>;
+		qcom,mdss-dsi-t-clk-pre = <0x22>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <255>;
+		qcom,mdss-dsi-dma-trigger = "trigger_sw";
+		qcom,mdss-dsi-mdp-trigger = "none";
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_pwm";
+		qcom,mdss-dsi-reset-sequence = <1 20>, <0 2>, <1 20>;
+	};
+};
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dtsi
index 08d34d6..fd55b71 100755
--- a/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dtsi
@@ -18,6 +18,7 @@
 #include "dsi-panel-hx8389b-qhd-video.dtsi"
 #include "dsi-panel-hx8394f-720p-video.dtsi"
 #include "dsi-panel-hx8394f-zzw500hah-720p-video.dtsi"
+#include "dsi-panel-he070na-lvds-600p-video.dtsi"
 
 &soc {
 	gpio-leds {
@@ -123,12 +124,12 @@
 };
 
 &mdss_dsi0 {
-	qcom,dsi-pref-prim-pan = <&dsi_otm8019a_fwvga_video>;
+	qcom,dsi-pref-prim-pan = <&dsi_he070na_lvds_600p_video>;
 	pinctrl-names = "mdss_default", "mdss_sleep";
 	pinctrl-0 = <&mdss_dsi_active>;
 	pinctrl-1 = <&mdss_dsi_suspend>;
 
-	qcom,platform-reset-gpio = <&msm_gpio 25 0>;
+	//qcom,platform-reset-gpio = <&msm_gpio 25 0>;
 };
 
 /*add by fangchengbing used for 753 project*/
@@ -155,6 +156,14 @@
 &dsi_hx8394f_720p_video {
     qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_wled";
     qcom,cont-splash-enabled;
+};
+
+&dsi_he070na_lvds_600p_video {
+       qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_pwm";
+       qcom,mdss-dsi-bl-pmic-pwm-frequency = <100>;
+       qcom,mdss-dsi-bl-pmic-bank-select = <0>;
+       qcom,mdss-dsi-pwm-gpio = <&pm8916_mpps 4 0>;
+       /*qcom,cont-splash-enabled;*/
 };
 
 
@@ -197,7 +206,18 @@
 		};
 	};
 };
+&i2c_5 {
+	/* added by eliot.shao, 2016.11.8 -start*/
+       icn6202_mipi_lvds {
+               compatible = "qcom,icn6202_mipi_lvds";
+               reg = <0x2D>;
+               enable_gpio {
+                       gpios = <&msm_gpio 25 0>;
+               };
+       };
+	/* added by eliot.shao, 2016.11.8 -end*/
 
+};
 &i2c_0 { /* BLSP1 QUP2 */
 // <-- add bmp280 driver @zhouwei 2016-05-10 
 	bmp280 {
@@ -294,7 +314,6 @@
 		invn,place = "Portrait Up Back Side";
 	};
 };
-
 &sdc2_cd_on {
 	/delete-property/ bias-pull-up;
 	bias-pull-down;
diff --git a/kernel/drivers/video/msm/mdss/Makefile b/kernel/drivers/video/msm/mdss/Makefile
old mode 100644
new mode 100755
index a5f4473..15faf75
--- a/kernel/drivers/video/msm/mdss/Makefile
+++ b/kernel/drivers/video/msm/mdss/Makefile
@@ -13,6 +13,7 @@
 mdss-mdp-objs += mdss_mdp_overlay.o
 mdss-mdp-objs += mdss_mdp_splash_logo.o
 mdss-mdp-objs += mdss_mdp_wb.o
+mdss-mdp-objs += icn6202_mipi_lvds.o
 obj-$(CONFIG_FB_MSM_MDSS) += mdss-mdp.o
 obj-$(CONFIG_FB_MSM_MDSS) += mdss_mdp_debug.o
 
diff --git a/kernel/drivers/video/msm/mdss/icn6202_mipi_lvds.c b/kernel/drivers/video/msm/mdss/icn6202_mipi_lvds.c
new file mode 100644
index 0000000..5626c80
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/icn6202_mipi_lvds.c
@@ -0,0 +1,223 @@
+/**
+ * @file icn6202_mipi_lvds.c
+ * @brief generate i2c_client, add an interface that other module can get the client
+ * @author fangchengbing
+ * @version 1.0
+ * @date 2015-05-04
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/errno.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+
+#define ICN6211_REG_0 (0xC1)
+#define ICN6202_ADD	(0x2D)
+
+struct icn6202_platform_data {
+	int en_gpio;
+};
+
+struct i2c_client *icn6202_i2c_client = NULL;
+static int icn6202_enable_gpio = -1;
+
+/*other module can get i2c_client by the interface*/
+struct i2c_client *mdss_get_icn6202_i2c_client(void)
+{
+	if (icn6202_i2c_client)
+		return icn6202_i2c_client;
+
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(mdss_get_icn6202_i2c_client);
+
+static int icn6202_set_enable(int enable_gpio)
+{
+	printk(KERN_ERR "[icn6202]: enable gpio number is %d\n", enable_gpio);
+
+	if (!gpio_is_valid(enable_gpio)) {
+		pr_err("[icn6202]: enable gpio is invaild\n");
+		return -1;
+	}
+
+	if (gpio_request(enable_gpio, "ICN6202_ENABLE") < 0) {
+		pr_err("[icn6202]: request enable gpio faild !\n");
+		return -1;
+	}
+
+	if (gpio_direction_output(enable_gpio, 1) < 0) {
+		pr_err("[icn6202]: set faild !\n");
+		return -1;
+	}
+
+	icn6202_enable_gpio = enable_gpio;
+
+	if (gpio_request(1018, "LCD_ENABLE_3V3") < 0) {
+		pr_err("[icn6202]: request lcd enable 3v3 enable gpio faild !\n");
+		return -1;
+	}
+
+	if (gpio_direction_output(1018, 1) < 0) {
+		pr_err("[icn6202]: %d, set faild !\n",__LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int icn6202_parse_dt(struct device *dev,
+		struct icn6202_platform_data *pdata)
+{
+	struct device_node *np = dev->of_node, *child;
+
+	for_each_child_of_node(np, child) {
+		enum of_gpio_flags flags;
+		pdata->en_gpio = of_get_gpio_flags(child, 0, &flags);;
+	}
+
+	pr_err("[icn6202], %s,enable-gpio number is %d\n", 
+			__func__,pdata->en_gpio);
+	return 0;
+}
+
+static int icn6202_resume(struct device *tdev) 
+{
+	if (icn6202_enable_gpio > 0)
+		gpio_direction_output(icn6202_enable_gpio, 1);
+	return 0;
+}
+
+static int icn6202_remove(struct i2c_client *client) {
+	return 0;
+}
+
+static int icn6202_suspend(struct device *tdev) 
+{
+	if (icn6202_enable_gpio > 0)
+		gpio_direction_output(icn6202_enable_gpio, 0);
+	return 0;
+}
+
+static int icn6202_probe(struct i2c_client *client,
+		const struct i2c_device_id *id) {
+	int ret;
+	struct icn6202_platform_data *pdata;
+
+	printk(KERN_ERR "[icn6202]: %s\n",__func__);
+
+	if (client->addr != ICN6202_ADD) {
+		printk(KERN_ERR "[icn6202]: Warning -- client->addr = 0x%02X\n",client->addr);
+		return -1;
+	}
+
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev,
+				sizeof(struct icn6202_platform_data),
+				GFP_KERNEL);
+		if (!pdata) {
+			pr_err("[icn6202]: Warning --Failed to allocate memory for pdata\n");
+			return -ENOMEM;
+		}
+
+		if (icn6202_parse_dt(&client->dev, pdata)) {
+			pr_err("[icn6202]: Warning -- parse dt faild!\n");
+			return -1;
+		}
+	} else {
+		pdata = client->dev.platform_data;
+	}
+
+	if (!pdata) {
+		dev_err(&client->dev, "[icn6202]: ICN6202 invalid pdata\n");
+		return -EINVAL;
+	}
+
+	/*set icn6202 enable gpio*/
+	if(icn6202_set_enable(pdata->en_gpio)) {
+		pr_err("[icn6202]: Waring, Enable icn6202 faild !\n");
+		return -1;
+	}
+
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "SMBUS Byte Data not Supported\n");
+		return -EIO;
+	}
+
+	ret = i2c_smbus_read_byte_data(client, 0);
+	if (ret < 0) {
+		dev_err(&client->dev, "[icn6202] i2c read fail: can't read from %02x: %d\n", 0, ret);
+		return ret;
+	} 
+
+	/*test i2c interface and ensure the chip is write*/
+	if (ret != ICN6211_REG_0) {
+		pr_err("[icn6202] val = 0x%x i2c is not ok or chip not write\n", ret);
+		return -1;
+	}
+
+	pr_err("[icn6202] icn6202_probe End..\n");
+	icn6202_i2c_client = client;
+	return 0;
+}
+
+static const struct of_device_id icn6202_mipi_lvds_of_match[] = {
+	{ .compatible = "qcom,icn6202_mipi_lvds",},
+	{},
+};
+
+static const struct i2c_device_id icn6202_id[] = {
+	{"icn6202_mipi_lvds", 0},
+	{},
+};
+
+static const struct dev_pm_ops icn6202_pm_ops =
+{ 
+	.suspend = icn6202_suspend,
+	.resume = icn6202_resume, 
+};
+
+static struct i2c_driver icn6202_driver = {
+	.driver = {
+		.name = "qcom,icn6202_mipi_lvds",
+		.owner    = THIS_MODULE,
+		.of_match_table = icn6202_mipi_lvds_of_match,
+		.pm = &icn6202_pm_ops,
+	},
+	.probe    = icn6202_probe,
+	.remove   = icn6202_remove,
+	.id_table = icn6202_id,
+};
+
+static int __init icn6202_init(void)
+{
+	printk(KERN_ERR "[icn6202]: %s",__func__);
+	return i2c_add_driver(&icn6202_driver);
+}
+
+static void __exit icn6202_exit(void)
+{
+	printk(KERN_ERR "[icn6202]: %s", __func__);
+	i2c_del_driver(&icn6202_driver);
+}
+
+module_init(icn6202_init);
+module_exit(icn6202_exit);
+
+MODULE_AUTHOR("shimin@meigsmart.com");
+MODULE_DESCRIPTION("ICN6202 MIPI-LVDS driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("i2c:icn6202_mipi_lvds");
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi.c b/kernel/drivers/video/msm/mdss/mdss_dsi.c
old mode 100644
new mode 100755
index 3250f49..53e122c
--- a/kernel/drivers/video/msm/mdss/mdss_dsi.c
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi.c
@@ -1419,7 +1419,7 @@
 	bool cmd_cfg_cont_splash = true;
 	struct mdss_panel_cfg *pan_cfg = NULL;
 	struct mdss_util_intf *util;
-
+	printk(KERN_ERR "[mdss_dsi_ctrl_probe]: %s\n",__func__);
 	util = mdss_get_util_intf();
 	if (util == NULL) {
 		pr_err("Failed to get mdss utility functions\n");
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi.h b/kernel/drivers/video/msm/mdss/mdss_dsi.h
old mode 100644
new mode 100755
index de1b3c5..8cfff21
--- a/kernel/drivers/video/msm/mdss/mdss_dsi.h
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi.h
@@ -23,6 +23,8 @@
 #include "mdss_panel.h"
 #include "mdss_dsi_cmd.h"
 
+#include "mdss_i2c_cmd.h"
+
 #define MMSS_SERDES_BASE_PHY 0x04f01000 /* mmss (De)Serializer CFG */
 
 #define MIPI_OUTP(addr, data) writel_relaxed((data), (addr))
@@ -282,6 +284,12 @@
 	DSI_CTRL_MAX,
 };
 
+/*enum that define type of access register default is dsi*/
+enum i2c_cmd_access_type {
+    CMD_ACCESS_DSI,
+    CMD_ACCESS_I2C,
+	CMD_ACCESS_ICN6202,
+};
 #define DSI_CTRL_LEFT		DSI_CTRL_0
 #define DSI_CTRL_RIGHT		DSI_CTRL_1
 #define DSI_CTRL_CLK_SLAVE	DSI_CTRL_RIGHT
@@ -354,6 +362,10 @@
 	bool dsi_irq_line;
 	atomic_t te_irq_ready;
 
+	//add by eliot shao 2016.11.9
+	int cmd_access ;
+	
+
 	bool cmd_clk_ln_recovery_en;
 	bool cmd_sync_wait_broadcast;
 	bool cmd_sync_wait_trigger;
@@ -368,6 +380,8 @@
 	u32 dsi_irq_mask;
 	struct mdss_hw *dsi_hw;
 	struct mdss_intf_recovery *recovery;
+	struct i2c_client *i2c_handle;		/*by mickey.shi*/
+	struct i2c_cmd_list i2c_on_cmds; /*by mickey.shi*/
 
 	struct dsi_panel_cmds on_cmds;
 	struct dsi_panel_cmds off_cmds;
@@ -479,6 +493,7 @@
 void mdss_dsi_wait4video_done(struct mdss_dsi_ctrl_pdata *ctrl);
 void mdss_dsi_en_wait4dynamic_done(struct mdss_dsi_ctrl_pdata *ctrl);
 int mdss_dsi_cmdlist_commit(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp);
+int mdss_i2c_cmdlist_commit(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp);
 void mdss_dsi_cmdlist_kickoff(int intf);
 int mdss_dsi_bta_status_check(struct mdss_dsi_ctrl_pdata *ctrl);
 int mdss_dsi_reg_status_check(struct mdss_dsi_ctrl_pdata *ctrl);
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi_host.c b/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
old mode 100644
new mode 100755
index e8e705b..63ec54c
--- a/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
@@ -110,8 +110,13 @@
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->tx_buf, SZ_4K);
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->rx_buf, SZ_4K);
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->status_buf, SZ_4K);
-	ctrl->cmdlist_commit = mdss_dsi_cmdlist_commit;
-
+	/*diff two register access type, mickey.shi, 8/30/2016*/
+	pr_err("eliot %s,%d, ctrl->cmd_access = %d\n", __func__,__LINE__,ctrl->cmd_access);
+	if (ctrl->cmd_access == CMD_ACCESS_DSI) {
+		ctrl->cmdlist_commit = mdss_dsi_cmdlist_commit;
+	} else if (ctrl->cmd_access == CMD_ACCESS_ICN6202) {
+		ctrl->cmdlist_commit = mdss_i2c_cmdlist_commit;
+	}
 
 	if (dsi_event.inited == 0) {
 		kthread_run(dsi_event_thread, (void *)&dsi_event,
@@ -1982,6 +1987,46 @@
 	return len;
 }
 
+/*
+ * @brief  write i2c command to mipi@rgb chip
+ * @author mickey.shi
+ * @param ctrl include i2c_client
+ * @param from_mdp not important
+ *
+ * @return
+ */
+int mdss_i2c_cmdlist_commit(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp)
+{
+	int rc = 0;
+	int i = 0;
+	struct i2c_cmd_list *on_cmds;
+
+	pr_err("Now into %s:\n", __func__);
+
+	if (!ctrl->i2c_handle) {
+		pr_err("%s, ctrl->i2c_handle is NULL !\n", __func__);
+		return rc;
+	}
+
+	on_cmds = &(ctrl->i2c_on_cmds);
+
+	mutex_lock(&ctrl->cmd_mutex);
+	for (i = 0; i < on_cmds->cmds_cnt; i++) {
+#if 1
+	pr_err("%s, [%d] , client->addr = 0x%2X, reg = [0x%02X], val = [0x%02X]\n",
+			__func__, i, ctrl->i2c_handle->addr, on_cmds->cmds[i].reg, on_cmds->cmds[i].val);
+#endif
+		rc = i2c_smbus_write_byte_data(ctrl->i2c_handle, on_cmds->cmds[i].reg, on_cmds->cmds[i].val);
+		if (rc < 0) {
+			pr_err("%s,%d, i2c cmd write faild !\n", __func__, __LINE__);
+			mutex_unlock(&ctrl->cmd_mutex);
+			return rc;
+		}
+	}
+
+	mutex_unlock(&ctrl->cmd_mutex);
+	return rc;
+}
 int mdss_dsi_cmdlist_commit(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp)
 {
 	struct dcs_cmd_req *req;
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c b/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
old mode 100644
new mode 100755
index fb83c75..7a41a30
--- a/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -617,9 +617,13 @@
 			goto end;
 	}
 
-	if (ctrl->on_cmds.cmd_cnt)
-		mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
-
+	if (ctrl->cmd_access == CMD_ACCESS_DSI) {
+		if (ctrl->on_cmds.cmd_cnt)
+			mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
+	} else if (ctrl->cmd_access == CMD_ACCESS_ICN6202) {
+		if (ctrl->i2c_on_cmds.cmds_cnt)
+			 ctrl->cmdlist_commit(ctrl, 0);
+	}
 end:
 	pinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;
 	pr_debug("%s:-\n", __func__);
@@ -727,6 +731,49 @@
 	}
 }
 
+/*
+ * @brief parse i2c command in dtsi file, format [%d %d] ==> [reg, val]
+ * store them in struct i2c_cmd_list
+ *
+ * @param np
+ * @param pcmds where i2c will store
+ * @param cmd_key flag contain i2c command
+ *
+ * @return
+ */
+static int mdss_i2c_parse_dcs_cmds(struct device_node *np,
+		struct i2c_cmd_list *pcmds, const char *cmd_key)
+{
+	const char *data;
+	int blen = 0;
+	char *buf;
+	int i = 0, j = 0;
+
+	data = of_get_property(np, cmd_key, &blen);
+	if (!data) {
+		pr_err("%s: failed, key=%s\n", __func__, cmd_key);
+		return -ENOMEM;
+	}
+
+	if (blen < 0 && blen / 2 == 1)
+		pr_err("%s format err\n", cmd_key);
+
+	buf = kzalloc(sizeof(char) * blen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, data, blen);
+	pcmds->cmds = kzalloc(sizeof(struct i2c_ctrl_hdr) * blen / 2, GFP_KERNEL);
+	pcmds->cmds_cnt = blen / 2;
+	for (i = 0; i < blen; i+=2)
+	{
+		j = i / 2;
+		pcmds->cmds[j].reg = buf[i];
+		pcmds->cmds[j].val = buf[i+1];
+	}
+
+	return 0;
+}
 
 static int mdss_dsi_parse_dcs_cmds(struct device_node *np,
 		struct dsi_panel_cmds *pcmds, char *cmd_key, char *link_key)
@@ -1607,6 +1654,23 @@
 	mdss_dsi_parse_reset_seq(np, pinfo->rst_seq, &(pinfo->rst_seq_len),
 		"qcom,mdss-dsi-reset-sequence");
 
+	/*Added by mickey.shi, 08/30/2016*/
+	if(of_property_read_bool(np,"qcom,mdss-icn6202-command")) {
+		ctrl_pdata->cmd_access = CMD_ACCESS_ICN6202;
+
+		pr_err("%s,%d, CMD_ACCESS_ICN6202\n",__func__,__LINE__);
+		ctrl_pdata->i2c_handle = mdss_get_icn6202_i2c_client();
+		if (!ctrl_pdata->i2c_handle) {
+			pr_err("ctrl_pdata->i2c_handle is null\n");
+		}
+
+		mdss_i2c_parse_dcs_cmds(np, &ctrl_pdata->i2c_on_cmds, "qcom,mdss-i2c-on-command");
+	} else if (of_property_read_bool(np,"qcom,mdss-i2c-command")) {
+		pr_err("%s,%d, CMD_ACCESS_I2C\n",__func__,__LINE__);
+		ctrl_pdata->cmd_access = CMD_ACCESS_I2C;
+	} else {
+		ctrl_pdata->cmd_access = CMD_ACCESS_DSI;
+		pr_err("%s,%d, CMD_ACCESS_DSI\n",__func__,__LINE__);
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->on_cmds,
 		"qcom,mdss-dsi-on-command", "qcom,mdss-dsi-on-command-state");
 
@@ -1616,6 +1680,7 @@
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->status_cmds,
 			"qcom,mdss-dsi-panel-status-command",
 				"qcom,mdss-dsi-panel-status-command-state");
+	}
 	rc = of_property_read_u32(np, "qcom,mdss-dsi-panel-status-value", &tmp);
 	ctrl_pdata->status_value = (!rc ? tmp : 0);
 
diff --git a/kernel/drivers/video/msm/mdss/mdss_i2c_cmd.h b/kernel/drivers/video/msm/mdss/mdss_i2c_cmd.h
new file mode 100644
index 0000000..5eb289d
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_i2c_cmd.h
@@ -0,0 +1,20 @@
+#ifndef __MDSS_I2C_CMD_H_
+#define __MDSS_I2C_CMD_H_
+/*struct that store a i2c command*/
+struct i2c_ctrl_hdr {
+	int rw_flags; /*0: read, 1: write*/
+	int reg;
+	int val;
+};
+
+/*i2c command*/
+struct i2c_cmd_list {
+	struct i2c_ctrl_hdr *cmds;
+	int cmds_cnt;
+};
+
+/*get the operation of i2c*/
+struct i2c_client *mdss_get_icn6202_i2c_client(void);
+
+#endif /*__MDSS_I2C_CMD_H_*/
+
